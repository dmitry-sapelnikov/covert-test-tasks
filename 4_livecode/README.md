## Overflow суммы
Интуиция не подвела насчет факта, что сумма при переполнении всегда будет меньше
обоих операндов, но строгое доказательство в голову на интервью не пришло.

Доказательство от противноого весьма простое:
допустим у нас есть 32 битное переполнение для результата `a + b = c`, и, не нарушая общности, `с >= a`
но для этого b должно быть равным `(1 << N) + (c - a)`, где `N >= 32` что невозможно, т.к по условию `b < (1 << 32)`

## Weighted moving average
Код и небольшой тест - в данной директории.
Я немного изменил подход, предложенный мне на интервью: я не игнорирую новое значение для текущего вызова, а использую данное значение с весом 1, мне такой подход кажется более естественным. Плюс я весую не по всей длине окна, если текущий пул значений на данный момент полностью не заполнил окно.
Контейнер для очереди я зашаблонил, используя для проверки соотвествия интерфейсу самописный концепт.
