## Overflow суммы
Интуиция не подвела насчет факта, что сумма при переполнении всегда будет меньше
обоих операндов, но строгое доказательство в голову на интервью не пришло.

Доказательство от противного:
допустим, у нас есть `N`-битное переполнение для результата `a + b = x % (1 << N)  = c`, где `x` - результат без overflow. 

Предположим, не нарушая общности, что `c >= a`,
но для этого `b` должно быть равным `(1 << k) + (c - a)`, где `k >= N`, что невозможно, т.к. по условию `b < (1 << N)`.

## Weighted moving average
Код класса — в [`moving_average.h`](moving_average.h)
Небольшой тест — в [`moving_average_test.cpp`](moving_average_test.cpp)

Я немного изменил подход, предложенный мне на интервью: я не игнорирую новое значение для текущего вызова, а использую данное значение с весом 1, мне такой подход кажется более естественным.
Контейнер для очереди я зашаблонил, используя для проверки соответствия интерфейсу самописный концепт.
