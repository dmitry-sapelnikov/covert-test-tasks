## Overflow суммы
Интуиция не подвела насчет факта, что сумма при переполнении всегда будет меньше
обоих операндов, но строгое доказательство в голову на интервью не пришло.

Доказательство от противного весьма простое:
допустим, у нас есть `N`-битное переполнение для результата `a + b = c`, и, не нарушая общности, `c >= a`,
но для этого `b` должно быть равным `(1 << k) + (c - a)`, где `k >= N`, что невозможно, т.к. по условию `b < (1 << N)`

## Weighted moving average
Код класса — в [`moving_average.h`](moving_average.h)
Небольшой тест — в [`moving_average_test.cpp`](moving_average_test.cpp)

Я немного изменил подход, предложенный мне на интервью: я не игнорирую новое значение для текущего вызова, а использую данное значение с весом 1, мне такой подход кажется более естественным. Плюс я взвешиваю не по всей длине окна, если текущий пул значений на данный момент полностью не заполнил окно.
Контейнер для очереди я зашаблонил, используя для проверки соответствия интерфейсу самописный концепт.

